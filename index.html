<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>움직임 × 집중 — 픽셀 실험 (MediaPipe Pose)</title>
    <style>
        html, body { height: 100%; }
        body { margin: 0; background: #fff; color: #111; font-family: Helvetica, Pretendard,sans-serif; overflow: hidden; }
        .wrap { display: grid; grid-template-rows: auto 1fr auto; gap: 8px; padding: 8px 12px; height: 100%; box-sizing: border-box; }
        h1 { margin: 0; font-size: 16px; font-weight: 600; color: #111; }
        .stage { position: fixed; inset: 0; background: #fff; }
        video { display: none; }
        canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
        .panel { position: fixed; left: 12px; bottom: 12px; display: flex; align-items: center; gap: 12px; color: #333; font-size: 14px; background: rgba(255,255,255,0.8); padding: 15px 15px; }
        .meter { min-width:180px; height: 12px; background: #262626; overflow: hidden; box-shadow: 0 0 0 1px rgba(0,0,0,0.06) inset; }
        .meter > i { display: block; height: 100%; width: 0%; background: #dbff4c; transition: width 100ms linear; }
        .note { position: fixed; right: 12px; bottom: 12px; font-size: 12px; color: #666; background: rgba(255,255,255,0.8); padding: 6px 8px; border-radius: 6px; }
        .moving { position: fixed; top: 50%; left: 50%; transform: translateX(-50%); padding: 8px 12px; color: #ffffff; font-weight: 700; font-size: 50px; display: none; }
        .btn { appearance: none; border: 0; padding: 15px 10px; background: #111; color: #dbff4c; cursor: pointer; font-family: inherit; font-size: 13px; }
        .btn:hover { background: #1f1f1f; }
        
        /* Title text */
        .title-text {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: 700;
            color: #111;
            z-index: 1000;
            text-align: center;
        }
        
        /* Focus Report Panel */
        .focus-report {
            position: fixed;
            left: 1200px;
            top: 80px;
            width: 280px;
            background: rgba(255, 255, 255, 0.4);
            padding: 20px;
            font-family: Helvetica,;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .focus-report h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #111;
        }
        
        .focus-report .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 24px;
            color: #333;
        }
        
        .focus-report .metric-label {
            font-weight: 500;
        }
        
        .focus-report .metric-value {
            font-weight: 600;
            color: #111;
        }
        
        .focus-report .status {
            margin-top: 15px;
            padding: 8px 20px;
            font-size: 33px;
            font-weight: 600;
            text-align: center;
        }
        
        .status.distracted {
            background: rgb(255, 0, 0);
            color: #ffffff;
        }
        
        .status.focused {
            background: rgb(0, 21, 255);
            color: #ffffff;
        }
        
      
        
        /* Description text */
        .description-text {
            position: fixed;
            left: 1150px;
            bottom: 20px;
            font-size: 16px;
            font-weight: 700;
            font-family: pretendard variable;
            color: #333;
            padding: 15px 20px;
            border-radius: 8px;
            max-width: 400px;
            line-height: 1.4;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <!-- Title Text -->
        <div class="title-text">DISTRACTION IS VISIBLE</div>
        
        <!-- Focus Report Panel -->
        <div class="focus-report">
            <h3>FOCUS REPORT</h3>
            <div class="metric">
                <span class="metric-label">Session Duration:</span>
                <span class="metric-value" id="session-timer">00:00:00</span>
            </div>
            <div class="metric">
                <span class="metric-label">Average Motion:</span>
                <span class="metric-value" id="average-motion">0.000</span>
            </div>
            <div class="metric">
                <span class="metric-label">Focus Score:</span>
                <span class="metric-value" id="focus-score">100</span>
            </div>
            <div class="metric">
                <span class="metric-label">Longest Stillness:</span>
                <span class="metric-value" id="longest-stillness">0s</span>
            </div>
            <div class="status" id="focus-status">Highly Distracted</div>
        </div>
    
        <div class="stage">
            <video id="input-video" playsinline></video>
            <canvas id="output-canvas"></canvas>
            <canvas id="detect-overlay"></canvas>
            <canvas id="text-overlay"></canvas>
        </div>
        <div class="moving" id="moving-badge">Moving...</div>
        <div class="panel">
            <span>MOVEMENT</span>
            <span class="meter"><i id="motion-bar"></i></span>
            <span id="pixel-size-label">pixel: -</span>
            <button id="btn-download" class="btn">이미지 저장</button>
        </div>
        
        <!-- Description Text -->
        <div class="description-text">
            이곳은 당신의 산만함을 시각적으로 보여주는 공간입니다. 당신의 집중력은 오늘 몇 점이었나요?
        </div>
       
    </div>

    <!-- MediaPipe Solutions CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    

    <script>
        const videoEl = document.getElementById('input-video');
        const canvasEl = document.getElementById('output-canvas');
        const ctx = canvasEl.getContext('2d', { willReadFrequently: true });
        const motionBar = document.getElementById('motion-bar');
        const pixelSizeLabel = document.getElementById('pixel-size-label');
        const movingBadge = document.getElementById('moving-badge');
        const btnDownload = document.getElementById('btn-download');
        
        // Focus Report Elements
        const sessionTimer = document.getElementById('session-timer');
        const averageMotion = document.getElementById('average-motion');
        const focusScore = document.getElementById('focus-score');
        const longestStillness = document.getElementById('longest-stillness');
        const focusStatus = document.getElementById('focus-status');

        // Offscreen helpers
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d', { willReadFrequently: true });

        // Results state
        let lastPoseLandmarks = null;
        let lastMotionEma = 0; // exponential moving average for stability
        let latestPoseImage = null; // last input frame size reference
        
        // Focus tracking variables
        let sessionStartTime = Date.now();
        let motionHistory = [];
        let stillnessStartTime = null;
        let currentStillnessDuration = 0;
        let longestStillnessDuration = 0;
        let lastMotionTime = Date.now();

        function ensureCanvasSize(width, height) {
            if (canvasEl.width !== width || canvasEl.height !== height) {
                canvasEl.width = width;
                canvasEl.height = height;
            }
            if (tmpCanvas.width !== width || tmpCanvas.height !== height) {
                tmpCanvas.width = width;
                tmpCanvas.height = height;
            }
        }
        
        // Session timer function
        function updateSessionTimer() {
            const elapsed = Date.now() - sessionStartTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            sessionTimer.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Update motion history and calculate average
        function updateMotionHistory(motion) {
            motionHistory.push(motion);
            // Keep only last 100 measurements (about 3-4 seconds at 30fps)
            if (motionHistory.length > 100) {
                motionHistory.shift();
            }
            
            const avgMotion = motionHistory.reduce((sum, m) => sum + m, 0) / motionHistory.length;
            averageMotion.textContent = avgMotion.toFixed(3);
            
            return avgMotion;
        }
        
        // Calculate focus score based on motion and stillness
        function calculateFocusScore(avgMotion, stillnessDuration) {
            // Base score starts at 100
            let score = 100;
            
            // More sensitive motion penalty (increased multiplier)
            const motionPenalty = Math.min(avgMotion * 400, 80); // Increased from 200 to 400, max penalty from 60 to 80
            score -= motionPenalty;
            
            // Reduced stillness bonus to make motion more impactful
            const stillnessBonus = Math.min(stillnessDuration / 20, 15); // Reduced from /10 to /20, max bonus from 20 to 15
            score += stillnessBonus;
            
            // Ensure score stays within 0-100 range
            return Math.max(0, Math.min(100, Math.round(score)));
        }
        
        // Update stillness tracking
        function updateStillnessTracking(motion) {
            const MOTION_THRESHOLD = 0.05; // Threshold for considering movement
            const currentTime = Date.now();
            
            if (motion < MOTION_THRESHOLD) {
                // Person is still
                if (stillnessStartTime === null) {
                    stillnessStartTime = currentTime;
                }
                currentStillnessDuration = (currentTime - stillnessStartTime) / 1000;
                
                // Update longest stillness if current is longer
                if (currentStillnessDuration > longestStillnessDuration) {
                    longestStillnessDuration = currentStillnessDuration;
                }
            } else {
                // Person is moving
                stillnessStartTime = null;
                currentStillnessDuration = 0;
            }
            
            longestStillness.textContent = `${Math.round(longestStillnessDuration)}s`;
        }
        
        // Update focus status
        function updateFocusStatus(score) {
            if (score >= 80) {
                focusStatus.textContent = "Highly Focused";
                focusStatus.className = "status focused";
            } else if (score >= 70) {
                focusStatus.textContent = "Moderately Focused";
                focusStatus.className = "status focused";
            } else if (score >= 60) {
                focusStatus.textContent = "Somewhat Distracted";
                focusStatus.className = "status distracted";
                ;
            } else {
                focusStatus.textContent = "Highly Distracted";
                focusStatus.className = "status distracted";
                ;
            }
        }

        // Motion from pose landmarks (mean L2 distance between frames)
        function computeMotion(prev, curr) {
            if (!prev || !curr || prev.length !== curr.length) return 0;
            let sum = 0;
            for (let i = 0; i < curr.length; i++) {
                const dx = curr[i].x - prev[i].x;
                const dy = curr[i].y - prev[i].y;
                const dz = (curr[i].z || 0) - (prev[i].z || 0);
                sum += Math.hypot(dx, dy, dz);
            }
            return sum / curr.length; // normalized because landmarks are in [0,1]
        }

        // Map motion → pixel size (larger motion → larger pixels)
        function pixelSizeFromMotion(motionNorm) {
            const minSize = 5;    // when still (more detailed)
            const maxSize = 48;   // when moving a lot (chunky)
            const DEADZONE = 0.07;  // ignore tiny jitters
            const SCALE = 0.06;     // require more motion for full effect
            const adjusted = Math.max(0, motionNorm - DEADZONE);
            const normalized = Math.min(1, adjusted / SCALE);
            const size = Math.round(minSize + (maxSize - minSize) * normalized);
            return Math.max(1, size);
        }

        // Render: draw pixelated webcam video with color-mapped tiles
        function renderFrame() {
            if (!latestPoseImage) return;
            const width = latestPoseImage.width;
            const height = latestPoseImage.height;
            ensureCanvasSize(width, height);

            // Downscale to sample colors, then draw solid-color tiles
            const motionPx = pixelSizeFromMotion(lastMotionEma);
            const tile = motionPx;
            const cols = Math.max(1, Math.floor(width / tile));
            const rows = Math.max(1, Math.floor(height / tile));

            tmpCtx.clearRect(0, 0, cols, rows);
            tmpCtx.drawImage(videoEl, 0, 0, cols, rows);
            const data = tmpCtx.getImageData(0, 0, cols, rows).data;
            const C0 = '#F5FFCB', C1 = '#DBFF49', C2 = '#E5E5E5', C3 = '#393939';

            // Clear main canvas and draw pixelated frame
            ctx.save();
            ctx.clearRect(0, 0, width, height);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const i = (y * cols + x) * 4;
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const lum = (0.2126*r + 0.7152*g + 0.0722*b) / 255; // 0..1
                    let color = C0;
                    if (lum < 0.25) color = C3;
                    else if (lum < 0.5) color = C2;
                    else if (lum < 0.75) color = C1;
                    else color = C0;
                    ctx.fillStyle = color;
                    ctx.fillRect(x * tile, y * tile, tile, tile);
                }
            }
            ctx.restore();

            // UI indicators
            {
                const DEADZONE = 0.01;
                const SCALE = 0.06;
                const adjusted = Math.max(0, lastMotionEma - DEADZONE);
                const normalized = Math.min(1, adjusted / SCALE);
                motionBar.style.width = `${Math.min(100, normalized * 100).toFixed(0)}%`;
            }
            pixelSizeLabel.textContent = `pixel: ${motionPx}px`;

            // Toggle Moving badge
            const DEADZONE = 0.07; const SCALE = 0.06;
            const norm = Math.min(1, Math.max(0, (lastMotionEma - DEADZONE) / SCALE));
            movingBadge.style.display = norm > 0.35 ? 'block' : 'none';
            
            // Update focus report
            updateSessionTimer();
            const avgMotion = updateMotionHistory(lastMotionEma);
            updateStillnessTracking(lastMotionEma);
            const score = calculateFocusScore(avgMotion, currentStillnessDuration);
            focusScore.textContent = score;
            updateFocusStatus(score);
        }

        // Download current canvas as PNG with Focus Report
        btnDownload.addEventListener('click', () => {
            // Create a new canvas for the report image
            const reportCanvas = document.createElement('canvas');
            const reportCtx = reportCanvas.getContext('2d');
            
            // Set canvas size (A4-like ratio)
            reportCanvas.width = 1200;
            reportCanvas.height = 800;
            
            // Fill background
            reportCtx.fillStyle = '#ffffff';
            reportCtx.fillRect(0, 0, reportCanvas.width, reportCanvas.height);
            
            // Draw the main pixelated image (scaled down)
            const imageScale = 0.96;
            const imageWidth = canvasEl.width * imageScale;
            const imageHeight = canvasEl.height * imageScale;
            const imageX = (reportCanvas.width - imageWidth) / 2;
            const imageY = 80; // Leave space for title
            
            reportCtx.drawImage(canvasEl, imageX, imageY, imageWidth, imageHeight);
            
            // Add title "MY FOCUS REPORT" at top center
            reportCtx.fillStyle = '#111111';
            reportCtx.font = 'bold 48px Helvetica';
            reportCtx.textAlign = 'center';
            reportCtx.fillText('MY FOCUS REPORT', reportCanvas.width / 2, 60);
            
            // Add focus report data at bottom right
            const reportData = [
                `Session Duration: ${sessionTimer.textContent}`,
                `Average Motion: ${averageMotion.textContent}`,
                `Focus Score: ${focusScore.textContent}`,
                `Longest Stillness: ${longestStillness.textContent}`,
                `Status: ${focusStatus.textContent}`
            ];
            
            reportCtx.font = '13pt Helvetica';
            reportCtx.textAlign = 'left';
            reportCtx.fillStyle = '#333333';
            
            const startX = reportCanvas.width - 1150;
            const startY = reportCanvas.height - 35;
            const lineHeight = 19;
            
            reportData.forEach((line, index) => {
                reportCtx.fillText(line, startX, startY - (reportData.length - index - 1) * lineHeight);
            });
            
            // Add timestamp
            const now = new Date();
            const timestamp = now.toLocaleString('ko-KR');
            reportCtx.font = '8pt Helvetica, Pretendard, sans-serif';
            reportCtx.fillStyle = '#666666';
            reportCtx.fillText(`Generated: ${timestamp}`, startX, startY + 20);
            
            // Download the report image
            const link = document.createElement('a');
            link.download = `focus-report-${Date.now()}.png`;
            link.href = reportCanvas.toDataURL('image/png');
            link.click();
        });

        // Pose setup
        const pose = new Pose({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        pose.onResults((res) => {
            latestPoseImage = res.image; // used for sizing
            if (res.poseLandmarks && res.poseLandmarks.length) {
                const motion = computeMotion(lastPoseLandmarks, res.poseLandmarks);
                // EMA smoothing
                const alpha = 0.08; // smoother, less reactive
                lastMotionEma = alpha * motion + (1 - alpha) * lastMotionEma;
                lastPoseLandmarks = res.poseLandmarks;
            }
            renderFrame();
        });

        async function start() {
            const desiredWidth = 960;
            const desiredHeight = 720; // 4:3-ish if camera supports
            videoEl.width = desiredWidth;
            videoEl.height = desiredHeight;

            const camera = new Camera(videoEl, {
                onFrame: async () => {
                    // Send the frame only to pose (for motion estimation)
                    await pose.send({ image: videoEl });
                },
                width: desiredWidth,
                height: desiredHeight
            });

            try {
                await camera.start();
            } catch (err) {
                console.error('Camera start error:', err);
                alert('카메라 접근 실패. HTTPS 또는 localhost에서 열고, 브라우저가 카메라 권한을 허용했는지 확인하세요.');
            }
        }

        start();
    </script>
    <!-- MediaPipe Tasks Object Detection (module) -->
    <script type="module">
        import { FilesetResolver, ObjectDetector } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17';

        const video = document.getElementById('input-video');
        const overlay = document.getElementById('detect-overlay');
        const octx = overlay.getContext('2d');

        let detector;
        let lastVideoTime = -1;

        function syncOverlaySize() {
            const w = video.videoWidth;
            const h = video.videoHeight;
            if (!w || !h) return false;
            if (overlay.width !== w || overlay.height !== h) {
                overlay.width = w;
                overlay.height = h;
            }
            return true;
        }

        async function initDetector() {
            const fileset = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm');
            detector = await ObjectDetector.createFromOptions(fileset, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite'
                },
                scoreThreshold: 0.5,
                runningMode: 'VIDEO'
            });
            requestAnimationFrame(loop);
        }

        function drawDetections(detections) {
            octx.clearRect(0, 0, overlay.width, overlay.height);
            if (!detections) return;
            octx.lineWidth = 3;
            octx.strokeStyle = '#ffffff';
            octx.fillStyle = '#ffffff';
            octx.font = '14px Helvetica, Arial, sans-serif';
            for (const d of detections) {
                const hasPerson = (d.categories || []).some(c => (c.categoryName || '').toLowerCase() === 'person');
                if (!hasPerson || !d.boundingBox) continue;
                const { originX, originY, width, height } = d.boundingBox;
                octx.strokeRect(originX, originY, width, height);
                const label = 'moving object';
                const pad = 4;
                const textW = octx.measureText(label).width;
                const textH = 16;
                octx.fillRect(originX, Math.max(0, originY - textH - pad*2), textW + pad*2, textH + pad*2);
                octx.fillStyle = '#000000';
                octx.fillText(label, originX + pad, Math.max(textH + pad, originY - pad));
                octx.fillStyle = '#ffffff';
            }
        }

        function loop() {
            if (!detector) return;
            if (!syncOverlaySize()) { requestAnimationFrame(loop); return; }
            const ts = performance.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const result = detector.detectForVideo(video, ts);
                drawDetections(result.detections);
            }
            requestAnimationFrame(loop);
        }

        initDetector();
    </script>
</body>
</html>

